/*
Copyright (c) 2017, The University of Bristol, Senate House, Tyndall Avenue, Bristol, BS8 1TH, United Kingdom.
Copyright (c) 2019, COSIC-KU Leuven, Kasteelpark Arenberg 10, bus 2452, B-3001 Leuven-Heverlee, Belgium.

All rights reserved
*/

#include <unistd.h>

#include "Online.h"
#include "Processor/Processor.h"
#include "OT/OT_Thread_Data.h"

extern OT_Thread_Data OTD;

extern vector<sacrificed_data> SacrificeD;
void getTriples(Processor &Proc, vector<Share> &sp, offline_control_data &OCD, int opcode)
{
  int thread = Proc.get_thread_num();

  switch (opcode)
  {
  case TRIPLE:
    if (sp.size() != 3)
      throw invalid_size();
    OCD.mul_mutex[thread].lock();
    sp[0] = SacrificeD[thread].TD.ta.front();
    SacrificeD[thread].TD.ta.pop_front();
    sp[1] = SacrificeD[thread].TD.tb.front();
    SacrificeD[thread].TD.tb.pop_front();
    sp[2] = SacrificeD[thread].TD.tc.front();
    SacrificeD[thread].TD.tc.pop_front();
    OCD.mul_mutex[thread].unlock();
    break;
  case SQUARE:
    if (sp.size() != 2)
      throw invalid_size();
    OCD.sqr_mutex[thread].lock();
    sp[0] = SacrificeD[thread].SD.sa.front();
    SacrificeD[thread].SD.sa.pop_front();
    sp[1] = SacrificeD[thread].SD.sb.front();
    SacrificeD[thread].SD.sb.pop_front();
    OCD.sqr_mutex[thread].unlock();
    break;
  case BIT:
    if (sp.size() != 1)
      throw invalid_size();
    OCD.bit_mutex[thread].lock();
    sp[0] = SacrificeD[thread].BD.bb.front();
    SacrificeD[thread].BD.bb.pop_front();
    OCD.bit_mutex[thread].unlock();
    break;
  default:
    throw bad_value();
    break;
  }
}

void online_000(Processor &Proc, int online_num, Player &P, offline_control_data &OCD, Machine &machine, int kkk)
{

  {
    gfp a(11), b(3), c(5);
    c = a + b;
    cout << P.whoami() << " ccccccccccc a + b:" << c << endl;
    c = a * b;
    cout << P.whoami() << " ccccccccccc a * b:" << c << endl;
    b.invert();
    cout << P.whoami() << " b.invert():" << b << endl;
    c = a * b;
    cout << P.whoami() << " ccccccccccc a / b:" << c << endl;
  }

  {

    cout << P.whoami() << " ccwhoami:" << endl;
    Share a, b, c;
    a.set_player(P.whoami());
    b.set_player(P.whoami());
    c.set_player(P.whoami());
    if (P.whoami() == 0)
    {
      gfp temp;
      temp.assign(3);
      a.assign(temp, P.get_mac_keys());
    }
    if (P.whoami() == 1)
    {
      gfp temp;
      temp.assign(4);
      b.assign(temp, P.get_mac_keys());
    }

    if (P.whoami() == 2)
    {
      gfp temp;
      temp.assign(5);
      c.assign(temp, P.get_mac_keys());
    }

    c = a + b;
    cout << P.whoami() << " ccccccccccc a + b:" << endl;
    c.output(cout, true);
  }
}

void online_add(Processor &Proc, int online_num, Player &P, offline_control_data &OCD, Machine &machine, int kkk)
{
  int p = P.whoami();
  {
    // add
    cout << P.whoami() << " ccwhoami---------22222:" << endl;
    Share a, b, c, d;
    a.set_player(P.whoami());
    b.set_player(P.whoami());
    c.set_player(P.whoami());

    // inputs
    //if (P.whoami() == 0)
    {
      Proc.iop.private_input2(0, a, 0, Proc, P, machine, OCD);
    }
    //if (P.whoami() == 1)
    {
      Proc.iop.private_input2(1, b, 0, Proc, P, machine, OCD);
    }
    //if (P.whoami() == 2)
    {
      Proc.iop.private_input2(2, c, 0, Proc, P, machine, OCD);
    }

    d = a + b + c;
    cout << P.whoami() << " ccccccccccc secret a + b + c:" << endl;
    d.output(cout, true);

    vector<int> start;
    size_t size = 1;
    vector<Share> vs = {d};
    vector<gfp> vgfp(vs.size());

    Proc.POpen_Start2(start, vs, size, P);
    Proc.POpen_Stop2(start, vgfp, size, P);
    cout << P.whoami() << " ccccccccccc clear a + b + c:" << endl;
    cout << vgfp[0] << endl;
    //vgfp[0].output(cout, true);
  }
}

void online_mul(Processor &Proc, int online_num, Player &P, offline_control_data &OCD, Machine &machine, int kkk)
{
  int p = P.whoami();

  {
    vector<Share> sp(3);
    for (int i = 0; i < sp.size(); i++)
    {
      sp[i].set_player(P.whoami());
    }

    getTriples(Proc, sp, OCD, TRIPLE);

    // inputs
    cout << P.whoami() << " ccwhoami---------22222:" << endl;
    Share a, b, c, d;
    a.set_player(P.whoami());
    b.set_player(P.whoami());
    c.set_player(P.whoami());
    //if (P.whoami() == 0)
    {
      Proc.iop.private_input2(0, a, 0, Proc, P, machine, OCD);
    }
    //if (P.whoami() == 1)
    {
      Proc.iop.private_input2(1, b, 0, Proc, P, machine, OCD);
    }
    //if (P.whoami() == 2)
    {
      Proc.iop.private_input2(2, c, 0, Proc, P, machine, OCD);
    }

    d = a + b + c;
    cout << P.whoami() << " ccccccccccc secret a + b + c:" << endl;
    d.output(cout, true);

    vector<int> start;
    size_t size = 1;
    vector<Share> vs = {d};
    vector<gfp> vgfp(vs.size());

    Proc.POpen_Start2(start, vs, size, P);
    Proc.POpen_Stop2(start, vgfp, size, P);
    cout << P.whoami() << " ccccccccccc clear a + b + c:" << endl;
    cout << vgfp[0] << endl;
    //vgfp[0].output(cout, true);

    {
      // mul
      /*
00 00 00 50 00 00 00 01 00 00 00 00 00 00 00 02     TRIPLE[a,b,c] --> Sp[1,0,2]
00 00 00 02 00 00 00 05 00 00 00 A3                 (y) A3 --> Sp[5]
00 00 00 26 00 00 00 04 00 00 00 05 00 00 00 00     (y-b) Sp[5] - Sp[0] --> Sp[4]
00 00 00 02 00 00 00 05 00 00 00 A6                 (x) A3 --> Sp[5]
00 00 00 26 00 00 00 03 00 00 00 05 00 00 00 01     (x-a) Sp[5] - Sp[1] --> Sp[3]
00 00 00 A0 00 00 00 02 00 00 00 03 00 00 00 04     (x-a,y-b) Sp[3,4] --> Open
00 00 00 A1 00 00 00 02 00 00 00 01 00 00 00 02     Open --> Cp[1,2]
00 00 00 31 00 00 00 03 00 00 00 00 00 00 00 01     Sp[0] * Cp[1] --> Sp[3]
00 00 00 21 00 00 00 00 00 00 00 02 00 00 00 03     Sp[2] + Sp[3] --> Sp[0]
00 00 00 31 00 00 00 02 00 00 00 01 00 00 00 02     Sp[1] * Cp[2] --> Sp[2]
00 00 00 21 00 00 00 01 00 00 00 00 00 00 00 02     Sp[0] + Sp[2] --> Sp[1]
00 00 00 30 00 00 00 00 00 00 00 01 00 00 00 02     Cp[1] * Cp[2] --> Cp[0]
00 00 00 22 00 00 00 00 00 00 00 01 00 00 00 00     Sp[1] + Cp[0] --> Sp[0]
00 00 00 A0 00 00 00 01 00 00 00 00                 Sp[0] --> Open
00 00 00 A1 00 00 00 01 00 00 00 00                 Open --> Cp[0]
      */
      auto xa = a - sp[0]; // x - a
      auto yb = b - sp[1]; // y - b
      vector<Share> vs = {xa, yb};
      vector<gfp> vgfp(vs.size());
      Proc.POpen_Start2(start, vs, size, P);
      Proc.POpen_Stop2(start, vgfp, size, P);
      cout << P.whoami() << " ccccccccccc clear:" << endl;
      cout << "vgfp[0]:" << vgfp[0] << endl;
      cout << "vgfp[1]:" << vgfp[1] << endl;
      {
        Share sp3 = sp[1] * vgfp[0];
        Share sp0 = sp[2] + sp3;

        Share sp2 = sp[0] * vgfp[1];
        Share sp1 = sp0 + sp2;

        gfp cp0 = vgfp[0] * vgfp[1];
        Share res;
        res.set_player(P.whoami());
        res.add(sp1, cp0, P.get_mac_keys());
        res.add(sp1, cp0, P.get_mac_keys());

        {

        }

        {
          vector<Share> vs = {res};
          vector<gfp> vgfp(vs.size());

          Proc.POpen_Start2(start, vs, size, P);
          Proc.POpen_Stop2(start, vgfp, size, P);
          cout << P.whoami() << " ccccccccccc ==> clear a * b:" << endl;
          cout << vgfp[0] << endl;
        }
      }
    }
  }
}
void online_inv(Processor &Proc, int online_num, Player &P, offline_control_data &OCD, Machine &machine, int kkk)
{
  int p = P.whoami();
}
void online_div(Processor &Proc, int online_num, Player &P, offline_control_data &OCD, Machine &machine, int kkk)
{
  int p = P.whoami();
  // div a/b
  {
    vector<Share> sp(3); // TRIPLE
    for (int i = 0; i < sp.size(); i++)
    {
      sp[i].set_player(P.whoami());
    }

    getTriples(Proc, sp, OCD, TRIPLE);

    vector<Share> sps(2); // SQUARE
    for (int i = 0; i < sps.size(); i++)
    {
      sps[i].set_player(P.whoami());
    }

    getTriples(Proc, sps, OCD, SQUARE);

    // inputs
    cout << P.whoami() << " ccwhoami---------22222:" << endl;
    Share a, b, c, d;
    a.set_player(P.whoami());
    b.set_player(P.whoami());
    c.set_player(P.whoami());
    //if (P.whoami() == 0)
    {
      Proc.iop.private_input2(0, a, 0, Proc, P, machine, OCD);
    }
    //if (P.whoami() == 1)
    {
      Proc.iop.private_input2(1, b, 0, Proc, P, machine, OCD);
    }
    //if (P.whoami() == 2)
    {
      Proc.iop.private_input2(2, c, 0, Proc, P, machine, OCD);
    }

    /*
    // phase 1
    a - a
    b - b
    00 00 00 50 00 00 00 04 00 00 00 00 00 00 00 05     TRIPLE[a,b,c] --> Sp[4,0,5]
    00 00 00 52 00 00 00 03 00 00 00 06                 SQUARE[a,b] --> Sp[3,6]
    00 00 00 26 00 00 00 01 00 00 00 03 00 00 00 04     Sp[3] - Sp[4] --> Sp[1]
    00 00 00 02 00 00 00 06 00 00 00 A3                 A3 --> Sp[6]
    00 00 00 26 00 00 00 02 00 00 00 06 00 00 00 00     Sp[6] - Sp[0] --> Sp[2]
    00 00 00 A0 00 00 00 02 00 00 00 01 00 00 00 02     Sp[1,2] --> Open
    00 00 00 A1 00 00 00 02 00 00 00 01 00 00 00 02     --> Cp[1,2]
    */
    gfp cpa, cpb;
    Share spa, spb, spc;
    spa.set_player(P.whoami());
    spb.set_player(P.whoami());
    spc.set_player(P.whoami());
    Share sp1 = sps[0] - sp[0];
    //Share sp2 = sps[1] - sp[1];
    Share sp2 = b - sp[1];

    vector<int> start;
    size_t size = 1;
    vector<Share> vs12 = {sp1, sp2};
    vector<gfp> cp12(vs12.size());
    Proc.POpen_Start2(start, vs12, size, P);
    Proc.POpen_Stop2(start, cp12, size, P);
    cout << "cp12[0]:" << cp12[0] << endl;
    cout << "cp12[1]:" << cp12[1] << endl;

    /*
    phase 2
    00 00 00 31 00 00 00 01 00 00 00 00 00 00 00 01     Sp[0] * Cp[1] --> Sp[1]
    00 00 00 21 00 00 00 00 00 00 00 05 00 00 00 01     Sp[5] + Sp[1] --> Sp[0]
    00 00 00 31 00 00 00 02 00 00 00 04 00 00 00 02     Sp[4] * Cp[2] --> Sp[2]
    00 00 00 21 00 00 00 01 00 00 00 00 00 00 00 02     Sp[0] + Sp[2] --> Sp[1]
    00 00 00 30 00 00 00 00 00 00 00 01 00 00 00 02     Cp[1] * Cp[2] --> Cp[0]
    00 00 00 22 00 00 00 00 00 00 00 01 00 00 00 00     Sp[1] + Cp[0] --> Sp[0]
    00 00 00 A0 00 00 00 01 00 00 00 00                 Sp[0] --> Open
    00 00 00 50 00 00 00 01 00 00 00 00 00 00 00 02     TRIPLE[a,b,c] --> Sp[1,0,2]
    00 00 00 01 00 00 00 02 00 00 00 01                 1 --> Cp[2]
    00 00 00 01 00 00 00 00 00 00 00 01                 1 --> Cp[0]
    00 00 00 31 00 00 00 04 00 00 00 03 00 00 00 00     Sp[3] * Cp[0] --> Sp[4]
    00 00 00 02 00 00 00 05 00 00 00 A6                 A6 --> Sp[5]
    00 00 00 26 00 00 00 03 00 00 00 05 00 00 00 01     Sp[5] - Sp[1] --> Sp[3]
    00 00 00 A1 00 00 00 01 00 00 00 01                 Open --> Cp[1]
    */
    sp1 = sp[1] * cp12[0];
    Share sp0 = sp[2] + sp1;
    sp2 = sp[0] * cp12[1];
    sp1 = sp0 + sp2;
    gfp cp0 = cp12[0] * cp12[1];
    sp0.add(sp1, cp0, P.get_mac_keys());
    vector<Share> vs0 = {sp0};
    Proc.POpen_Start2(start, vs0, size, P);

    /*
    phase 3
    00 00 00 50 00 00 00 01 00 00 00 00 00 00 00 02     TRIPLE[a,b,c] --> Sp[1,0,2]
    00 00 00 01 00 00 00 02 00 00 00 01                 1 --> Cp[2]
    00 00 00 01 00 00 00 00 00 00 00 01                 1 --> Cp[0]
    00 00 00 31 00 00 00 04 00 00 00 03 00 00 00 00     Sp[3] * Cp[0] --> Sp[4]
    00 00 00 02 00 00 00 05 00 00 00 A6                 A6 --> Sp[5]
    00 00 00 26 00 00 00 03 00 00 00 05 00 00 00 01     Sp[5] - Sp[1] --> Sp[3]
    00 00 00 A1 00 00 00 01 00 00 00 01                 Open --> Cp[1]
    */
    getTriples(Proc, sp, OCD, TRIPLE);
    gfp cp2 = 1;
    cp0 = 1;
    Share sp4 = sps[0] * cp0;
    Share sp3 = a - sp[0];

    vector<gfp> vcp0(vs0.size());
    Proc.POpen_Stop2(start, vcp0, size, P);
    cout << "vcp0[0]:" << vcp0[0] << endl;

    /*
    phase 4
    00 00 00 34 00 00 00 00 00 00 00 02 00 00 00 01     INV(Cp[1]) * Cp[2] --> Cp[0]
    */
    if (vcp0[0].is_zero())
      throw Processor_Error("Division by zero from register");
    gfp tmp;
    tmp.invert(vcp0[0]);
    tmp.mul(cp2);
    cp0 = tmp;

    /*
    phase 5
    00 00 00 31 00 00 00 05 00 00 00 04 00 00 00 00     Sp[4] * Cp[0] --> Sp[5]
    00 00 00 26 00 00 00 04 00 00 00 05 00 00 00 00     Sp[5] - Sp[0] --> Sp[4]
    00 00 00 A0 00 00 00 02 00 00 00 03 00 00 00 04     Sp[3,4] --> Open
    00 00 00 A1 00 00 00 02 00 00 00 01 00 00 00 02     --> Cp[1,2]
    00 00 00 31 00 00 00 03 00 00 00 00 00 00 00 01     Sp[0] * Cp[1] --> Sp[3]
    00 00 00 21 00 00 00 00 00 00 00 02 00 00 00 03     Sp[2] + Sp[3] --> Sp[0]
    00 00 00 31 00 00 00 02 00 00 00 01 00 00 00 02     Sp[1] * Cp[2] --> Sp[2]
    00 00 00 21 00 00 00 01 00 00 00 00 00 00 00 02     Sp[0] + Sp[2] --> Sp[1]
    00 00 00 30 00 00 00 00 00 00 00 01 00 00 00 02     Cp[1] * Cp[2] --> Cp[0]
    00 00 00 22 00 00 00 00 00 00 00 01 00 00 00 00     Sp[1] + Cp[0] --> Sp[0]
    00 00 00 A0 00 00 00 01 00 00 00 00                 Sp[0] --> Open
    00 00 00 A1 00 00 00 01 00 00 00 00                 --> Cp[0]
    */
    Share sp5 = sp4 * cp0;
    sp4 = sp5 - sp[1];
    vector<Share> vs34 = {sp3, sp4};
    vector<gfp> cp34(vs34.size());
    Proc.POpen_Start2(start, vs34, size, P);
    Proc.POpen_Stop2(start, cp34, size, P);

    //
    sp3 = sp[1] * cp34[0];
    sp0 = sp[2] + sp3;
    sp2 = sp[0] * cp34[1];
    sp1 = sp0 + sp2;
    cp0 = cp34[0] * cp34[1];
    sp0.add(sp1, cp0, P.get_mac_keys());

    {
      vector<Share> vs0 = {sp0};
      Proc.POpen_Start2(start, vs0, size, P);
      vector<gfp> vcp0(vs0.size());
      Proc.POpen_Stop2(start, vcp0, size, P);
      cout << ">>>>>>> vcp0[0]:" << vcp0[0] << endl;
    }
  }
}